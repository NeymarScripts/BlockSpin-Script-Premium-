local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Block Spin Script " .. Fluent.Version,
    SubTitle = "by Freddy And Seth",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "crop" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    Combat = Window:AddTab({ Title = "Combat", Icon = "crosshair" }),
    Esp = Window:AddTab({ Title = "Visuals", Icon = "skull" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Notification",
        Content = "This is a notification",
        SubContent = "SubContent", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
    })






    Tabs.Main:AddSection("FREE AUTO FARM (NO BAN)")
    Tabs.Main:AddParagraph({
        Title = "Paragraph",
        Content = "OPEN THE AUTO FARM UI HERE"
    })

    Tabs.Main:AddButton({ 
        Title = "AUTO FARM",
        Description = "BEST AUTO FARM MENU",
        Callback = function()
            Window:Dialog({
                Title = "Confirmaci√≥n",
                Content = "¬øAre you sure you want to execute this?",
                Buttons = {
                    {
                        Title = "Yes",
                        Callback = function()
                            loadstring(game:HttpGet("https://raw.githubusercontent.com/xQuartyx/QuartyzScript/refs/heads/main/Block%20Spin/Default.lua"))()
                        end
                    },
                    {
                        Title = "No",
                        Callback = function()
                            print("Cancelado.")
                        end
                    }
                }
            })
        end
    })

    Tabs.Combat:AddSection("SILENT")
    Tabs.Combat:AddParagraph({
        Title = "Paragraph",
        Content = "THIS SILENT AIM IS FOR PCS ONLY.  Execute the Silent Aim just Once, or u will get bugged"
    })

    Tabs.Combat:AddButton({ 
        Title = "Silent Aim (PCS ONLY)",
        Description = "Best Silent Aim",
        Callback = function()
            Window:Dialog({
                Title = "Confirmaci√≥n",
                Content = "¬øAre you sure you want to execute this?",
                Buttons = {
                    {
                        Title = "Yes",
                        Callback = function()
                            loadstring(game:HttpGet("https://raw.githubusercontent.com/SETHHHX/test/refs/heads/main/YOU%20KNOW"))()
                        end
                    },
                    {
                        Title = "No",
                        Callback = function()
                            print("Cancelado.")
                        end
                    }
                }
            })
        end
    })
    
    

    

Tabs.Main:AddSection("Manually Auto Hack (U need to be near an ATM")

--AUTO HACK

local ATMModule = require(game.ReplicatedStorage.Modules.Game.ATM.ATM)
local Net = require(game.ReplicatedStorage.Modules.Core.Net)
local ItemUtils = require(game.ReplicatedStorage.Modules.Game.Inventory.ItemUtils)
local Data = require(game.ReplicatedStorage.Modules.Core.Data)
local HackTools = require(game.ReplicatedStorage.Modules.Game.ATM.ATMUI).valid_hack_tools
local Char = require(game.ReplicatedStorage.Modules.Core.Char)
local HRP = Char.get_hrp
local LocalPlayer = game.Players.LocalPlayer

-- üîß Toggle y Slider
local Toggle = Tabs.Main:AddToggle("ATM Farm", {Title = "ATM Farm", Default = false}) 
local AutoFarm = false

Toggle:OnChanged(function()
    AutoFarm = Options["ATM Farm"].Value
    print("ATM Farm toggle:", AutoFarm)
end)

Options["ATM Farm"]:SetValue(false)

local DelayBetweenHacks = 2
local AutoWinDelay = 1 -- Nuevo delay antes de atm_win_2

local Slider = Tabs.Main:AddSlider("ATM Delay", {
    Title = "Hack Delay",
    Description = "Delay to Start the hack",
    Default = 2,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        DelayBetweenHacks = Value
        print("Delay actualizado a:", DelayBetweenHacks)
    end
})

-- üîÅ Loop de hackeo autom√°tico y victoria
task.spawn(function()
    while true do
        if AutoFarm then
            for _, atm in ATMModule.class.objects do
                local model = atm.instance
                if model and model:IsDescendantOf(workspace) then
                    local isDisabled = atm.states.disabled:get()
                    local isBeingHacked = atm.states.hacker:get() ~= nil
                    local distance = (HRP().Position - model:GetPivot().Position).Magnitude

                    if not isDisabled and not isBeingHacked and distance < 15 then
                        local validTool = nil
                        for _, tool in HackTools do
                            local toolName = tool.Name
                            if ItemUtils.get_item_count(Data, "misc", toolName) > 0 then
                                validTool = toolName
                                break
                            end
                        end

                        if validTool then
                            print("üîê Iniciando hackeo:", model.Name)
                            Net.send("request_begin_hacking_2", model, validTool)

                            task.wait(AutoWinDelay) -- üí° Delay antes del auto-win

                            Net.send("atm_win_2", model)
                            print("‚úÖ Hack completado autom√°ticamente:", model.Name)

                            task.wait(DelayBetweenHacks)
                        end
                    end
                end
            end
        end
        task.wait(1)
    end
end)









--ESP THINGS


Tabs.Esp:AddSection("ATMS")

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")

local atmEspConnection
local ATMModule = require(game.ReplicatedStorage.Modules.Game.ATM.ATM)

-- Crea o actualiza el Highlight de un modelo ATM
local function updateHighlight(model, isActive)
    local existing = CoreGui:FindFirstChild("ATMESP_" .. model:GetDebugId())
    if not existing then
        local highlight = Instance.new("Highlight")
        highlight.Name = "ATMESP_" .. model:GetDebugId()
        highlight.Adornee = model
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineTransparency = 0
        highlight.Parent = CoreGui
        existing = highlight
    end

    existing.FillColor = isActive and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    existing.FillTransparency = 0.5
end

-- Elimina todos los ESPs anteriores
local function clearESP()
    for _, obj in ipairs(CoreGui:GetChildren()) do
        if obj:IsA("Highlight") and obj.Name:match("^ATMESP_") then
            obj:Destroy()
        end
    end
end

-- Dibuja/actualiza los ESPs din√°micamente
local function drawESP()
    for _, atm in ipairs(Workspace.Map.Props:GetChildren()) do
        if atm.Name == "ATM" then
            local isActive = false
            for _, obj in ATMModule.class.objects do
                if obj.instance == atm then
                    isActive = not obj.states.disabled:get()
                    break
                end
            end
            updateHighlight(atm, isActive)
        end
    end
end

-- ‚úÖ Toggle con Fluent UI
local Toggle = Tabs.Esp:AddToggle("ATMESP_Toggle", {
    Title = "ATM ESP",
    Default = false
})

Toggle:OnChanged(function()
    if Options.ATMESP_Toggle.Value then
        atmEspConnection = RunService.RenderStepped:Connect(function()
            pcall(drawESP)
        end)
    else
        if atmEspConnection then
            atmEspConnection:Disconnect()
            atmEspConnection = nil
        end
        clearESP()
    end
end)

Options.ATMESP_Toggle:SetValue(false)











--PLAYER ESP
Tabs.Esp:AddSection("PLAYERS ESP")


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local nameESP = {}
local connections = {}
local updateConnection

-- Crear name tag para jugador
local function createNameTag(player)
    if nameESP[player] then return end

    local text = Drawing.new("Text")
    text.Size = 13
    text.Center = true
    text.Outline = true
    text.Font = 2
    text.Color = Color3.fromRGB(255, 255, 255)
    text.Visible = false

    nameESP[player] = text
end

-- Eliminar name tag
local function removeNameTag(player)
    if nameESP[player] then
        nameESP[player]:Remove()
        nameESP[player] = nil
    end
end

-- Actualizar name tag
local function updateNameTag(player)
    local text = nameESP[player]
    if not text then return end

    local character = player.Character
    if not character then text.Visible = false return end

    local head = character:FindFirstChild("Head")
    if not head then text.Visible = false return end

    local pos, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
    if not onScreen then text.Visible = false return end

    local distance = (Camera.CFrame.Position - head.Position).Magnitude
    local size = math.clamp(20 - distance * 0.15, 13, 20)

    text.Text = player.Name
    text.Size = size
    text.Position = Vector2.new(pos.X, pos.Y - size - 5)
    text.Visible = true
end

-- üü¢ Toggle (Fluent UI) con limpieza completa
local Toggle = Tabs.Esp:AddToggle("PlayerNames", {
    Title = "Names",
    Default = false
})

Toggle:OnChanged(function()
    if Options.PlayerNames.Value then
        -- Crear name tag para jugadores actuales
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                if player.Character then
                    createNameTag(player)
                end
                connections[player] = player.CharacterAdded:Connect(function()
                    task.wait(0.1)
                    createNameTag(player)
                end)
            end
        end

        -- Nuevos jugadores
        connections["PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player == LocalPlayer then return end
            connections[player] = player.CharacterAdded:Connect(function()
                task.wait(0.1)
                createNameTag(player)
            end)
        end)

        -- Jugadores que se van
        connections["PlayerRemoving"] = Players.PlayerRemoving:Connect(function(player)
            removeNameTag(player)
            if connections[player] then
                connections[player]:Disconnect()
                connections[player] = nil
            end
        end)

        -- Actualizaci√≥n por frame
        updateConnection = RunService.RenderStepped:Connect(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and nameESP[player] then
                    updateNameTag(player)
                end
            end
        end)
    else
        -- Apagar y limpiar
        if updateConnection then updateConnection:Disconnect() updateConnection = nil end

        for _, text in pairs(nameESP) do
            text:Remove()
        end

        for _, conn in pairs(connections) do
            conn:Disconnect()
        end

        table.clear(nameESP)
        table.clear(connections)
    end
end)

Options.PlayerNames:SetValue(false)


--HIGHLIGHT


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local Toggle = Tabs.Esp:AddToggle("High", {Title = "Highlight", Default = false})

-- Variable para controlar si el highlight est√° activado
local highlightEnabled = Toggle.Value

local function isCharacterValid(char)
    return char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Head")
end

local function applyHighlight(char)
    if not char:FindFirstChild("BodyESP") and isCharacterValid(char) then
        local hl = Instance.new("Highlight")
        hl.Name = "BodyESP"
        hl.Adornee = char
        hl.FillTransparency = 1 -- solo borde
        hl.OutlineTransparency = 0
        hl.OutlineColor = Color3.fromRGB(255, 0, 0)
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Parent = char
    end
end

local function removeHighlight(char)
    local hl = char:FindFirstChild("BodyESP")
    if hl then
        hl:Destroy()
    end
end

local function waitForValidCharacter(player, callback)
    task.spawn(function()
        local char = player.Character or player.CharacterAdded:Wait()
        local tries = 0
        while not isCharacterValid(char) and tries < 50 do
            task.wait(0.1)
            tries += 1
        end
        if isCharacterValid(char) then
            callback(char)
        end
    end)
end

local function setupPlayer(player)
    if player == LocalPlayer then return end

    -- Esperar a que el personaje sea v√°lido y aplicar highlight
    waitForValidCharacter(player, function(char)
        if highlightEnabled then
            applyHighlight(char)
        else
            removeHighlight(char)
        end
    end)

    -- Escuchar la creaci√≥n de un nuevo personaje
    player.CharacterAdded:Connect(function(char)
        waitForValidCharacter(player, function()
            if highlightEnabled then
                applyHighlight(char)
            else
                removeHighlight(char)
            end
        end)
    end)
end

-- Funci√≥n para actualizar todos los jugadores seg√∫n el toggle
local function updateAllPlayers()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and isCharacterValid(player.Character) then
            local char = player.Character
            if highlightEnabled then
                applyHighlight(char)
            else
                removeHighlight(char)
            end
        end
    end
end

-- Aplicar highlight a jugadores actuales
for _, player in ipairs(Players:GetPlayers()) do
    setupPlayer(player)
end

-- Nuevos jugadores
Players.PlayerAdded:Connect(setupPlayer)

-- Reforzar cada frame y actualizar jugadores sin highlight si el toggle est√° activado
RunService.Heartbeat:Connect(function()
    updateAllPlayers()
end)

-- Actualizar el valor de highlightEnabled cuando cambie el toggle
Toggle:OnChanged(function()
    highlightEnabled = Toggle.Value
    print("Toggle changed:", highlightEnabled)

    -- Actualizar todos los jugadores
    updateAllPlayers()
end)

-- Inicializar el valor del toggl



--BOX
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local esp = {}
local connections = {}
local espConnection

local function createESP(player)
    if esp[player] then return end

    local boxOutline = Drawing.new("Square")
    boxOutline.Thickness = 4
    boxOutline.Color = Color3.new(0, 0, 0)
    boxOutline.Filled = false
    boxOutline.Visible = false

    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Color = Color3.fromRGB(0, 255, 255)
    box.Filled = false
    box.Visible = false

    local healthBar = Drawing.new("Line")
    healthBar.Thickness = 2
    healthBar.Color = Color3.fromRGB(0, 255, 0)
    healthBar.Visible = false

    esp[player] = {
        Box = box,
        Outline = boxOutline,
        Health = healthBar
    }
end

local function removeESP(player)
    if esp[player] then
        if esp[player].Box then esp[player].Box:Remove() end
        if esp[player].Outline then esp[player].Outline:Remove() end
        if esp[player].Health then esp[player].Health:Remove() end
        esp[player] = nil
    end
end

local function updateESP(player, character)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end

    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
    if not onScreen then
        esp[player].Box.Visible = false
        esp[player].Outline.Visible = false
        if esp[player].Health then esp[player].Health.Visible = false end
        return
    end

    local scaleFactor = 1.6
    local height = 6 * scaleFactor
    local top = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, height / 2, 0))
    local bottom = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, height / 2, 0))

    local boxHeight = math.abs(top.Y - bottom.Y)
    local boxWidth = boxHeight / 2

    local x = pos.X - boxWidth / 2
    local y = pos.Y - boxHeight / 2

    -- Box
    local box = esp[player].Box
    box.Position = Vector2.new(x, y)
    box.Size = Vector2.new(boxWidth, boxHeight)
    box.Visible = true

    local outline = esp[player].Outline
    outline.Position = box.Position
    outline.Size = box.Size
    outline.Visible = true

    -- Health bar
    if Options.HealthBar.Value then
        local hpRatio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local barHeight = boxHeight * hpRatio
        local barX = x - 6
        local barY = y + boxHeight

        local health = esp[player].Health
        health.From = Vector2.new(barX, barY)
        health.To = Vector2.new(barX, barY - barHeight)
        health.Visible = true

        if hpRatio > 0.5 then
            health.Color = Color3.fromRGB(0, 255, 0)
        elseif hpRatio > 0.25 then
            health.Color = Color3.fromRGB(255, 255, 0)
        else
            health.Color = Color3.fromRGB(255, 0, 0)
        end
    else
        esp[player].Health.Visible = false
    end
end

-- ‚úÖ Toggle con l√≥gica completa
local Toggle = Tabs.Esp:AddToggle("BoxESP", {Title = "Box ESP", Default = false})
local HealthToggle = Tabs.Esp:AddToggle("HealthBar", {Title = "Health Bar", Default = false})

Toggle:OnChanged(function()
    if Options.BoxESP.Value then
        -- Crear ESP a todos los jugadores actuales
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                if player.Character then
                    createESP(player)
                end
                connections[player] = player.CharacterAdded:Connect(function()
                    task.wait(0.1)
                    createESP(player)
                end)
            end
        end

        -- Detectar nuevos jugadores
        connections["PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player == LocalPlayer then return end
            connections[player] = player.CharacterAdded:Connect(function()
                task.wait(0.1)
                createESP(player)
            end)
        end)

        -- Detectar jugadores que se van
        connections["PlayerRemoving"] = Players.PlayerRemoving:Connect(function(player)
            removeESP(player)
            if connections[player] then
                connections[player]:Disconnect()
                connections[player] = nil
            end
        end)

        -- Actualizar cada frame
        espConnection = RunService.RenderStepped:Connect(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character and esp[player] then
                    updateESP(player, player.Character)
                end
            end
        end)
    else
        -- Apagar todo
        if espConnection then espConnection:Disconnect() espConnection = nil end

        for player, _ in pairs(esp) do
            removeESP(player)
        end

        for _, conn in pairs(connections) do
            conn:Disconnect()
        end

        table.clear(esp)
        table.clear(connections)
    end
end)

Options.BoxESP:SetValue(false)
Options.HealthBar:SetValue(false)




local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local tracers = {}
local connections = {}
local tracerConnection

-- Crear tracer para un jugador
local function createTracer(player)
    if tracers[player] then return end

    local tracer = Drawing.new("Line")
    tracer.Thickness = 1.5
    tracer.Color = Color3.fromRGB(255, 255, 255)
    tracer.Visible = false

    tracers[player] = tracer
end

-- Eliminar tracer
local function removeTracer(player)
    if tracers[player] then
        tracers[player]:Remove()
        tracers[player] = nil
    end
end

-- Actualizar tracer
local function updateTracer(player)
    local character = player.Character
    local tracer = tracers[player]
    if not character or not tracer then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        tracer.Visible = false
        return
    end

    local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
    if not onScreen then
        tracer.Visible = false
        return
    end

    local from = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
    local to = Vector2.new(pos.X, pos.Y)

    tracer.From = from
    tracer.To = to
    tracer.Visible = true
end

-- ‚úÖ Toggle con l√≥gica completa
local Toggle = Tabs.Esp:AddToggle("PlayerTracers", {
    Title = "Player Tracers",
    Default = false
})

Toggle:OnChanged(function()
    if Options.PlayerTracers.Value then
        -- Crear tracer a todos los jugadores actuales
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                if player.Character then
                    createTracer(player)
                end
                connections[player] = player.CharacterAdded:Connect(function()
                    task.wait(0.1)
                    createTracer(player)
                end)
            end
        end

        -- Nuevos jugadores
        connections["PlayerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player == LocalPlayer then return end
            connections[player] = player.CharacterAdded:Connect(function()
                task.wait(0.1)
                createTracer(player)
            end)
        end)

        -- Jugadores que se van
        connections["PlayerRemoving"] = Players.PlayerRemoving:Connect(function(player)
            removeTracer(player)
            if connections[player] then
                connections[player]:Disconnect()
                connections[player] = nil
            end
        end)

        -- Actualizaci√≥n cada frame
        tracerConnection = RunService.RenderStepped:Connect(function()
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and tracers[player] then
                    updateTracer(player)
                end
            end
        end)
    else
        -- Apagar y limpiar todo
        if tracerConnection then tracerConnection:Disconnect() tracerConnection = nil end

        for _, tracer in pairs(tracers) do
            tracer:Remove()
        end

        for _, conn in pairs(connections) do
            conn:Disconnect()
        end

        table.clear(tracers)
        table.clear(connections)
    end
end)

Options.PlayerTracers:SetValue(false)





--PLAYER TAB


local Toggle = Tabs.Player:AddToggle("InfStamina", {Title = "Infinite Stamina", Default = false })

Toggle:OnChanged(function()
    if Options.InfStamina.Value then
        local Player = game:GetService("Players").LocalPlayer

        -- Esperamos a que los atributos est√©n disponibles
        task.spawn(function()
            repeat task.wait() until Player:GetAttribute("StaminaConsumeMultiplier") ~= nil and Player:GetAttribute("StaminaRegen") ~= nil

            -- Aplicamos la stamina infinita
            Player:SetAttribute("StaminaConsumeMultiplier", 0)
            Player:SetAttribute("StaminaRegen", 9999)
        end)
    else
        local Player = game:GetService("Players").LocalPlayer

        -- Restauramos los valores por defecto (ajusta si los conoces)
        Player:SetAttribute("StaminaConsumeMultiplier", 1)
        Player:SetAttribute("StaminaRegen", 1)
    end
end)

Options.InfStamina:SetValue(false)









--INVENTORY VIEWER

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local screenGui, frame, contentFrame
local viewerRunning = false
local viewerThread

-- Variables de tama√±o
local fullHeight = 300
local minimizedHeight = 35
local isMinimized = false

-- Funci√≥n para bordes redondeados
local function addCorner(instance, radius)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, radius)
	corner.Parent = instance
end

-- Funci√≥n para iniciar Inventory Viewer
local function startViewer()
	if viewerRunning then return end
	viewerRunning = true

	-- Crear UI principal
	screenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
	screenGui.Name = "InventoryView"
	screenGui.ResetOnSpawn = false

	-- Frame
	frame = Instance.new("Frame", screenGui)
	frame.Size = UDim2.new(0, 270, 0, 0)
	frame.Position = UDim2.new(0, 20, 0.5, -150)
	frame.BackgroundColor3 = Color3.fromRGB(15, 25, 40)
	frame.BorderSizePixel = 2
	frame.BorderColor3 = Color3.fromRGB(0, 120, 255)
	frame.Active = true
	frame.Draggable = true
	frame.ZIndex = 1
	addCorner(frame, 10)

	frame:TweenSize(UDim2.new(0, 270, 0, fullHeight), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.4, true)

	-- Title bar
	local titleBar = Instance.new("Frame", frame)
	titleBar.Size = UDim2.new(1, 0, 0, 35)
	titleBar.BackgroundColor3 = Color3.fromRGB(52, 20, 55)
	titleBar.BorderSizePixel = 1
	titleBar.BorderColor3 = Color3.fromRGB(0, 120, 255)
	addCorner(titleBar, 10)

	local title = Instance.new("TextLabel", titleBar)
	title.Size = UDim2.new(1, -40, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.BackgroundTransparency = 1
	title.TextColor3 = Color3.fromRGB(200, 200, 255)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 16
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Text = "Inventario de: ---"

	local toggleBtn = Instance.new("TextButton", titleBar)
	toggleBtn.Size = UDim2.new(0, 35, 1, 0)
	toggleBtn.Position = UDim2.new(1, -35, 0, 0)
	toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
	toggleBtn.BorderSizePixel = 1
	toggleBtn.BorderColor3 = Color3.fromRGB(0, 100, 200)
	toggleBtn.Font = Enum.Font.GothamBold
	toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleBtn.Text = "‚àí"
	toggleBtn.TextSize = 20
	addCorner(toggleBtn, 6)

	toggleBtn.MouseEnter:Connect(function()
		toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 160, 255)
	end)
	toggleBtn.MouseLeave:Connect(function()
		toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
	end)

	contentFrame = Instance.new("Frame", frame)
	contentFrame.Size = UDim2.new(1, 0, 1, -35)
	contentFrame.Position = UDim2.new(0, 0, 0, 35)
	contentFrame.BackgroundColor3 = Color3.fromRGB(38, 18, 50)
	contentFrame.BorderSizePixel = 1
	contentFrame.BorderColor3 = Color3.fromRGB(0, 90, 180)
	addCorner(contentFrame, 10)

	local inventoryList = Instance.new("UIListLayout", contentFrame)
	inventoryList.Padding = UDim.new(0, 6)
	inventoryList.SortOrder = Enum.SortOrder.LayoutOrder

	local padding = Instance.new("UIPadding", contentFrame)
	padding.PaddingTop = UDim.new(0, 5)
	padding.PaddingLeft = UDim.new(0, 8)
	padding.PaddingRight = UDim.new(0, 8)

	local function clearInventory()
		for _, child in ipairs(contentFrame:GetChildren()) do
			if child:IsA("TextLabel") then
				child:Destroy()
			end
		end
	end

	local function showInventoryFor(player)
		if not player or not player:IsA("Player") or player == LocalPlayer then return end

		clearInventory()
		title.Text = "Inventory of: " .. player.Name

		local backpack = player:FindFirstChild("Backpack")
		if backpack then
			for _, tool in pairs(backpack:GetChildren()) do
				if tool:IsA("Tool") then
					local label = Instance.new("TextLabel", contentFrame)
					label.Size = UDim2.new(1, 0, 0, 24)
					label.BackgroundColor3 = Color3.fromRGB(70, 28, 25)
					label.TextColor3 = Color3.fromRGB(230, 230, 255)
					label.Font = Enum.Font.Gotham
					label.TextSize = 14
					label.Text = "üõ†Ô∏è " .. tool.Name
					label.TextXAlignment = Enum.TextXAlignment.Left
					label.BackgroundTransparency = 0
					label.BorderSizePixel = 1
					label.BorderColor3 = Color3.fromRGB(0, 80, 160)
					addCorner(label, 6)
				end
			end
		end
	end

	local function getClosestPlayerToMouse(maxDist)
		local closest, closestDist = nil, maxDist or 100
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
				if onScreen then
					local dist = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
					if dist < closestDist then
						closest = player
						closestDist = dist
					end
				end
			end
		end
		return closest
	end

	toggleBtn.MouseButton1Click:Connect(function()
		isMinimized = not isMinimized
		contentFrame.Visible = not isMinimized
		frame.Size = isMinimized and UDim2.new(0, 270, 0, minimizedHeight) or UDim2.new(0, 270, 0, fullHeight)
		toggleBtn.Text = isMinimized and "+" or "‚àí"
	end)

	-- Loop de actualizaci√≥n
	viewerThread = task.spawn(function()
		while viewerRunning do
			local targetPlayer = getClosestPlayerToMouse(100)
			if targetPlayer then
				showInventoryFor(targetPlayer)
			end
			task.wait(0.5)
		end
	end)
end

-- Funci√≥n para detener Inventory Viewer
local function stopViewer()
	viewerRunning = false
	if viewerThread then
		task.cancel(viewerThread)
	end
	if screenGui then
		screenGui:Destroy()
	end
end

-- Toggle integraci√≥n (AJUSTA esto a tu sistema de UI)
local Toggle = Tabs.Player:AddToggle("Viewer", {Title = "Inventory Viewer", Default = false}) 

Toggle:OnChanged(function(value)
    if value then
        startViewer()
    else
        stopViewer()
    end
end)

Options.Viewer:SetValue(false)





Tabs.Combat:AddSection("AIMLOCK")

--AIMLOCK 



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local AimlockEnabled = false
local AimPart = "Head"
local AimKey = Enum.KeyCode.Q
local LockedPlayer = nil -- üß† Jugador que fue seleccionado para el aimlock

-- UI
local Toggle = Tabs.Combat:AddToggle("Aimbot", {Title = "Aimlock", Default = false})
local Keybind = Tabs.Combat:AddKeybind("AimlockKey", {
    Title = "Aimlock Keybind",
    Mode = "Toggle",
    Default = "Q",
})

local Dropdown = Tabs.Combat:AddDropdown("AimPartSelect", {
    Title = "Aimlock Target Part",
    Values = {"Head", "UpperTorso"},
    Multi = false,
    Default = "Head"
})

-- Cambiar parte del cuerpo
Dropdown:OnChanged(function(value)
    AimPart = value
end)

-- Cambiar keybind
Keybind:OnChanged(function(value)
    AimKey = Enum.KeyCode[value]
end)

-- Buscar jugador m√°s cercano al cursor (solo al presionar la tecla)
local function GetClosestPlayerToCursor()
    local closest, shortestDistance = nil, math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(AimPart) then
            local part = player.Character[AimPart]
            local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)

            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
                if dist < shortestDistance then
                    shortestDistance = dist
                    closest = player
                end
            end
        end
    end

    return closest
end

-- Cuando presion√°s la keybind
Keybind:OnClick(function()
    if Options.Aimbot.Value then
        if AimlockEnabled then
            -- Si ya estaba activado, lo apaga
            AimlockEnabled = false
            LockedPlayer = nil
        else
            -- Activa aimlock con el jugador bajo el cursor
            local target = GetClosestPlayerToCursor()
            if target then
                AimlockEnabled = true
                LockedPlayer = target
            end
        end
    end
end)

-- Si el toggle se apaga, desactiva todo
Toggle:OnChanged(function()
    if not Options.Aimbot.Value then
        AimlockEnabled = false
        LockedPlayer = nil
    end
end)

-- Loop
RunService.RenderStepped:Connect(function()
    if Options.Aimbot.Value and AimlockEnabled and LockedPlayer and LockedPlayer.Character and LockedPlayer.Character:FindFirstChild(AimPart) then
        local part = LockedPlayer.Character[AimPart]
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, part.Position)
    end
end)





Tabs.Combat:AddSection("EXTRA")
--ANTI KILL

local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer
    
    local character, humanoid, hrp
    
    local function updateCharacter()
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        hrp = character:WaitForChild("HumanoidRootPart")
    end
    
    -- Inicializar personaje
    updateCharacter()
    
    -- Reiniciar cuando el personaje reaparece
    player.CharacterAdded:Connect(function()
        evading = false -- Reinicia la evasi√≥n al reaparecer
        updateCharacter()
    end)
    
    local evading = false
    local antiKillEnabled = false
    
    -- Toggle
    local Toggle = Tabs.Combat:AddToggle("AntiKill", {Title = "Anti Kill", Default = false })
    
    Toggle:OnChanged(function()
        antiKillEnabled = Options.AntiKill.Value
        print("AntiKill toggle changed:", antiKillEnabled)
    end)
    
    Options.AntiKill:SetValue(false)
    
    -- Funcionalidad AntiKill
    RunService.RenderStepped:Connect(function()
        if not antiKillEnabled then return end
        if not character or not humanoid or not hrp then return end
        if humanoid.Health <= 16 and not evading then
            evading = true
            print("üõ°Ô∏è Activando evasi√≥n con mayor elevaci√≥n...")
    
            local originPosition = hrp.Position
            local elevatedHeight = originPosition.Y + 10
    
            task.spawn(function()
                while humanoid.Health < 30 and antiKillEnabled and humanoid.Parent do
                    local randomOffset = Vector3.new(
                        math.random(-40, 40),
                        0,
                        math.random(-40, 40)
                    )
    
                    local targetPosition = originPosition + randomOffset
                    local moveDirection = (targetPosition - hrp.Position).Unit
                    local moveDistance = math.random(10, 25)
    
                    hrp.Velocity = moveDirection * moveDistance * 10
                    hrp.CFrame = CFrame.new(hrp.Position.X, elevatedHeight, hrp.Position.Z)
    
                    task.wait(0.05)
                end
    
                print("üü¢ Salud restaurada o toggle desactivado. Evasi√≥n finalizada.")
                evading = false
            end)
        end
    end)


















-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
end
